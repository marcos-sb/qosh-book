\chapter{A Private Cloud for MapReduce Applications}\label{cap:solucion}
\noindent This chapter introduces a novel solution combining the virtual infrastructure managed with OpenStack and the Hadoop implementation of MapReduce to conform a powerful computational tandem. \emph{qosh}, as this project has been called, will be described along this section moving from architecture to implementation.

\section{Architecture}\label{sec:diseno}
\noindent Figure \ref{fig:arquitecturaglobal} shows a high level portrait of qosh execution environment. The component that acts as interface between system and user is displayed on the right end. It abstracts the inherent difficulty in configuring the job execution context and in deploying the virtual cluster. Furthermore, qosh will keep track of submitted jobs, MapReduce \texttt{jar} files, input data and output results, with no need to walk the HDFS to search for data.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.65\textwidth]{imagenes/021.pdf}
 \caption{Global Architecture}
\label{fig:arquitecturaglobal}
\end{center}
\end{figure}

To streamline development, it is determined that the very first qosh version be tested on a personal computer. As shown on figure \ref{fig:arquitecturaglobal}, Fedora Linux is installed atop the hardware and OpenStack Folsom set up within. qosh will draw on the infrastructure provided by the local OpenStack configuration to deploy virtual Hadoop clusters. While it would be better to make qosh more flexible allowing for remote infrastructure consumption, it would also become harder to test.

Figure \ref{fig:arquitecturadetalle} shows a more detailed view on qosh design details. The VM contains a Hadoop installation ready to be put to use as soon as it was started. The VM life cycle is managed by OpenStack and its execution environment shaped by KVM, the chosen hypervisor. Besides, HDFS has been used as temporal persistence layer while the results are not send back to the controller --- the same machine in this testing environment. It shall be recalled that even though HDFS is a steady data store, the Hadoop VMs are created and removed for every work flow execution effectively destroying HDFS data at the end of processing each job. So, it is qosh's job to orchestrate data extraction before shutting down the virtual cluster.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.85\textwidth]{imagenes/022.pdf}
 \caption{Detailed global architecture}
\label{fig:arquitecturadetalle}
\end{center}
\end{figure}

Figure \ref{fig:arquitecturainterfaz} shows the modular decomposition of qosh orchestration module.

\begin{figure}[bp]
\begin{center}
\includegraphics[width=0.8\textwidth]{imagenes/023.pdf}
 \caption{Core qosh modular decomposition}
\label{fig:arquitecturainterfaz}
\end{center}
\end{figure}

\begin{description}
 \item[Compute:] Acts as client to OpenStack REST API. It handles every interaction with the cloud decoupling qosh fromt the particular IaaS Cloud.
 \item[Django:] Is used in qosh to let users manage their MapReduce executions with ease via a web interface.
 \item[Fabric:] Is the Python library included in qosh to configure the virtual cluster deployment and destruction.
\end{description}

\subsection{Design Diagrams}\label{subsec:diagramasaltonivel}
\noindent Below are shown the design diagrams that make up the section on high level overview of the project.

\subsubsection{Django Components}\label{subsubsec:componentesdjango}
\noindent Figure \ref{fig:instalaciondjango} portrays modules adjacent to Django to support its operation.

\begin{figure}[bp]
\begin{center}
\includegraphics[width=0.23\textwidth]{imagenes/024.pdf}
 \caption{Django setup}
\label{fig:instalaciondjango}
\end{center}
\end{figure}

\begin{description}
 \item[Apache httpd:] Relied on to manage user interaction with OpenStack Dashboard, it may also be used to with qosh web interface. Initially, qosh depends on Python web server module to handle user requests, but \emph{httpd} might be easily configured.
 \item[memcached:] Is employed to cache web pages in order to speedup load times.
 \item[MySQL:] Chosen relational DBMS to store job meta-data.
\end{description}


\subsubsection{Use Cases Diagram}\label{subsubsec:casosuso}
\noindent Figure \ref{fig:casosuso} displays the set of use cases that have been considered for qosh. It reflects the five fundamental agents comprising the system.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/025.pdf}
 \caption{Use Cases Diagram}
\label{fig:casosuso}
\end{center}
\end{figure}

\subsubsection{Machine State Diagram}\label{subsubsec:navegacion}
\noindent Figure \ref{fig:navegacion} presents a summary on the navigation flow across the web interface. An example interaction is subsequently described.

Initially, the user is presented the \emph{Login} page so that he/she could log into qosh. If the supplied credentials were cleared --- the user must be previously registered in Keystone as user/pass is shared with qosh ---, the \emph{Main} page is shown. From there the user may \emph{Configure Job} or go over the \emph{Job History} to get some \emph{Job Details}.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/026.pdf}
 \caption{Web interface transitions}
\label{fig:navegacion}
\end{center}
\end{figure}

\subsubsection{Diagrama de Clases --- M\'odulo Compute}\label{subsubsec:diagramaclasescompute}
\noindent La figura \ref{fig:diagramaclasescompute1} muestra un peque\~no Diagrama de Clases que describe las relaciones del cliente de acceso al API REST con algunos m\'odulos de Fabric y Python.

\begin{description}
 \item[json:] \emph{parsea} y maneja datos estructurados en formato JSON. El API REST de OpenStack entiende tanto XML como JSON.
 \item[Exception:] clase Python que representa una excepci\'on gen\'erica.
 \item[ServiceError:] extensi\'on de \texttt{Exception}. Se utiliza como contenedor de los errores que pudiesen aparecer al interactuar con el servicio REST. Est\'a compuesto por el c\'odigo y la descripci\'on del error HTTP que se produzca.
 \item[Environment:] recoge las variables globales de configuraci\'on de la interfaz.
 \item[httplib:] es el paquete Python que contiene las funciones y clases necesarias para establecer comunicaciones HTTP. Se usa en este proyecto para consumir el servicio REST.
\end{description}

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.5\textwidth]{imagenes/027.pdf}
 \caption{Diagrama de Clases del cliente de acceso REST (I)}
\label{fig:diagramaclasescompute1}
\end{center}
\end{figure}


\section{Implementaci\'on}\label{sec:implementacion}
\noindent Los tres m\'odulos que componen la interfaz se han escrito en Python. Las pruebas de la primera versi\'on corren sobre las versiones 1.4.3 de Fabric, 1.4.2 de Django y 2.7.3 de Python. La configuraci\'on dentro de la m\'aquina virtual, para permitir su acceso desde el cloud, se realiza con tres scripts, escritos en \texttt{bash-script}, que se activan en tres momentos diferentes del ciclo de vida del servidor virtual: antes de configurar la red, despu\'es de haber arrancado con \'exito y antes de destruirse.


\subsection{M\'aquina virtual}\label{subsec:maquinavirtual}
\noindent Una parte importante del proyecto ha sido la construcci\'on de la m\'aquina virtual que contiene la instalaci\'on de Hadoop 1.0.4 y el JRE 1.7 de Oracle. Su configuraci\'on y puesta a punto no result\'o un proceso muy complejo, pero s\'i lo suficientemente interesante y largo, por ser reutilizable para cualquier m\'aquina virtual que se pretenda preparar para correr en un cloud, como para elaborar una lista con todos los pasos seguidos. El entorno de instalaci\'on es el citado MacBook 6,1 bajo un Fedora 17 actualizado.
\begin{itemize}
    \item Se a\~nadi\'o con \texttt{yum} el \emph{Virtual Machine Manager} (\texttt{virt-manager}) y sus librer\'ias dependientes, entre las que destacamos: la librer\'ia de vir\-tua\-li\-za\-ci\'on (\texttt{libvirt}), el m\'odulo del kernel para el hypervisor (KVM) y un \emph{wrapper} de ese m\'odulo para gestionar su uso (QEMU).
 \item Utilizando el Virtual Machine Manager se configur\'o una m\'aquina virtual con 1 GB de RAM, 4 GB de disco en formato \emph{QCOW2} y tanto APIC como ACPI.
 \item Se prosigui\'o con la instalaci\'on en red de la \'ultima versi\'on estable de CentOS (la 6.3), eligiendo \emph{Basic Server} como conjunto de paquetes instalados por defecto; en una sola partici\'on ext4 y sin LVM.
 \item Al reiniciar, se pidi\'o a yum que actualizase todos los paquetes del sistema.
 \item Se descargaron desde las webs oficiales las versiones comentadas del JRE y Hadoop y se instalaron con \texttt{rpm}.
 \item Se cre\'o el usuario \emph{hduser} con grupo principal \emph{hadoop} y se retocaron los permisos de los ficheros relacionados con Hadoop ---ficheros de con\-fi\-gu\-ra\-ci\'on y scripts.
 \item Se configur\'o \texttt{sshd} para impedir la conexi\'on como \emph{root} y el acceso utilizando nombre de usuario y contrase\~na como credenciales; s\'olo se permite establecer t\'uneles SSH usando la parte privada de la clave que inyecta OpenStack en la m\'aquina virtual en cada arranque.
 \item Se escribieron tres scripts (\texttt{/etc/init.d/cloud-*}) para personalizar el comportamiento de la m\'aquina virtual, como escribir en su lugar (\texttt{/home/hduser/.ssh/authorized\_keys}) la clave p\'ublica de acceso SSH inyectada por el cloud.
 \item Se eliminaron, con \texttt{yum groups}, servicios no utilizados, como el \emph{X-server}.
 \item Se compact\'o la imagen QCOW2 creando un fichero indeterminadamente grande, con \texttt{dd}, y comprimiendo, desde el anfitri\'on, con \texttt{qemu-img}.
 \item Con \texttt{qemu-nbd} se mont\'o la imagen de la m\'aquina virtual como un dispositivo de bloque en red y con \texttt{fdisk} se observaron el tama\~no del bloque y el bloque inicial de la partici\'on que contiene la instalaci\'on de Hadoop, para calcular su desplazamiento con respecto al inicio del disco virtual.
 \item Finalmente, de nuevo con \texttt{qemu-nbd} se mont\'o la imagen con el des\-pla\-za\-mien\-to calculado, para extraer la \'unica partici\'on (la ra\'iz) del disco virtual contenido en la imagen. Asimismo, se copiaron al anfitri\'on tanto el kernel como la \emph{initram} de la instalaci\'on de CentOS.
\end{itemize}



\subsection{Diagramas de implementaci\'on}\label{subsec:diagramasimpl}
\noindent Acto seguido se exponen aquellos diagramas que describen el proyecto desde un punto m\'as cercano a su implementaci\'on.


\subsubsection{Diagrama de Clases --- M\'odulo Compute}\label{subsubsec:implementacioncompute}
\noindent La figura \ref{fig:diagramaclasescompute2} expande el detalle del m\'odulo \texttt{Compute} de la figura \ref{fig:diagramaclasescompute1}. El comportamiento de las funciones se deduce f\'acilmente de las firmas de la figura. Si cabe, destacar que la nomenclatura utilizada para describir algunos tipos de funciones ---un tipo diccionario y un tipo lista, recuerda a la sintaxis de Python que declara esos tipos.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/028.pdf}
 \caption{Diagrama de Clases del cliente de acceso REST (II)}
\label{fig:diagramaclasescompute2}
\end{center}
\end{figure}

\begin{description}
 \item[Lista:] \texttt{[TipoDeTodosLosValores]}
 \item[Diccionario:] \texttt{\{<Clave1> : <TipoValor1> ,<Clave2> : <TipoValor2>\}}
\end{description}


\subsubsection{Diagrama de Clases --- Django y Fabric}\label{subsubsec:clasesdjangofabric}
\noindent La figura \ref{fig:djangoyfabric} expone las relaciones entre los m\'odulos m\'as importantes de Django y Fabric. Veamos algunos comentarios sobre el diagrama.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/029.pdf}
 \caption{Diagrama de Clases --- Django y Fabric}
\label{fig:djangoyfabric}
\end{center}
\end{figure}

\begin{description}
 \item[Views:] es una clase Django que implementa el comportamiento de cada \emph{vista} (p\'agina web) de la interfaz del proyecto. Interact\'ua directamente con \texttt{Compute} para manejar la comunicaci\'on con el cloud.
 \item[Process:] es una clase wrapper que encapsula tanto el comportamiento de creaci\'on de un proceso \texttt{multiprocessing.Process} como la funci\'on que ejecutar\'a el proceso creado. Esta funci\'on de \texttt{mapred.Process}, cuya firma no se ha incluido por simplicidad, controla el procesado de las instancias Hadoop a trav\'es de \texttt{Compute} y \texttt{Fabfile} (Fabric).
 \item[OpenStackBackend:] es un peque\~no backend que gestiona la conexi\'on de los usuarios. Django incluye un sistema bastante completo para manejar las credenciales de conexi\'on, pero en este proyecto hemos decidido apoyarnos en el de OpenStack para evitar la duplicidad de los usuarios, sus contrase\~nas y datos del perfil. Por tanto, el papel de este backend es hacer de \emph{puente} entre el sistema integrado de credenciales de Django y el de OpenStack; cada petici\'on de conexi\'on se reenv\'ia al \emph{pipe} de acceso a OpenStack. Es decir, s\'olo es necesario que el usuario est\'e registrado en el cloud soporte, OpenStack en nuestro caso, para lanzar trabajos MapReduce.
 \item[OSServer y OSFlavor:] son clases \emph{helper} que desacoplan a la interfaz del servicio REST. Crean representaciones equivalentes en forma de objetos de los JSON que procesan como resultado de las invocaciones de \texttt{Compute}.
\end{description}



\subsubsection{Diagrama de Clases --- Objetos de Django}\label{subsubsec:clasesobjetosdjango}
\noindent La figura \ref{fig:clasesobjetosdjango} contiene, en detalle, las relaciones entre las \emph{clases de objetos del modelo concreto} de Django.


\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/030.pdf}
 \caption{Diagrama de Clases --- Objetos de Django}
\label{fig:clasesobjetosdjango}
\end{center}
\end{figure}


\begin{description}
 \item[django.db.models:] este paquete lo proporciona la distribuci\'on de Django. Sirve de apoyo para escribir objetos del modelo de aplicaci\'on, basados en composiciones y extensiones de las clases contenidas.
  \begin{description}
   \item[Model:] es la clase base de los objetos del modelo, esto es, todo objeto de nuestro minimundo ha de ser \emph{descendiente} suyo. Usando esta clase y las definiciones de las clases de objetos, Django se encargar\'a de gestionar todo lo relativo a la persistencia de los objetos del modelo en una base de datos.
   \item[Fields:] son algunas de las implementaciones m\'as usuales de campos de inter\'es para los objetos que, junto con \texttt{Model}, permiten que Django establezca la morfolog\'ia del esquema l\'ogico de la base de datos asociada.
  \end{description}
 \item[Job:] representa un trabajo MapReduce para Hadoop. Comentar que se ha especializado la definici\'on del m\'etodo \texttt{save}, para poder organizar los trabajos en el sistema de ficheros por su identificador en la base de datos. Tal y como se ha comentado, la salvaguarda de informaci\'on de cada \texttt{Job} en una base datos corre a cargo de Django.
 \item[Server:] es la representaci\'on de la configuraci\'on individual de cada m\'aquina virtual que participe en un trabajo Hadoop MapReduce.
 \item[User:] es la clase interna de Django que almacena la informaci\'on de los usuarios de la interfaz. Se utiliza como \emph{Transfer Object} desde el sistema de autorizaci\'on de OpenStack como portador de los datos de los usuarios en cada \emph{sesi\'on}.
\end{description}


\subsubsection{Diagrama de Clases --- Formularios de Django}\label{subsubsec:clasesformulariosdjango}
\noindent La figura \ref{fig:clasesformulariosdjango} muestra la descomposici\'on en clases de los formularios que recogen las credenciales de acceso y la configuraci\'on del procesado. El paquete \texttt{django.forms} tiene organizaci\'on y finalidad id\'enticos al paquete \texttt{django.db.\\models} comentado anteriormente. En este caso \texttt{Form}, junto con los \texttt{Field} necesarios, es la clase extensible que aporta Django para concretar los formularios de usuario.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/031.pdf}
 \caption{Diagrama de Clases --- Formularios de Django}
\label{fig:clasesformulariosdjango}
\end{center}
\end{figure}

\begin{description}
 \item[LoginForm:] formulario de conexi\'on de usuarios. Formado por un par de campos car\'acter que recogen el nombre de usuario y su contrase\~na en OpenStack.
 \item[JobForm:] es el formulario que permite definir la computaci\'on para \\MapReduce. Incluye: el prefijo del nombre de los servidores virtuales que se crear\'an, el nombre cualificado de la clase implementaci\'on de las funciones Map y Reduce, el fichero de entrada (paquete comprimido), el paquete \emph{Jar} que contiene la clase implementaci\'on, el n\'umero de servidores virtuales necesarios y su \emph{flavor} computacional.
\end{description}


\subsubsection{Diagrama Entidad-Relaci\'on}\label{subsubsec:entidadrelacion}
\noindent Se hab\'ia apuntado brevemente que Django posee la habilidad de construir autom\'aticamente el esquema l\'ogico de una base de datos relacional derivando el modelo de objetos escrito por el desarrollador. Era de esperar que la gesti\'on de las operaciones \emph{CRUD} (\emph{Create, Read, Update, Delete}) sobre las tuplas almacenadas tambi\'en estuviese implementada. La figura \ref{fig:entidadrelacion} muestra el diagrama Entidad-Relaci\'on correspondiente a la gesti\'on de trabajos. Se han omitido las entidades y relaciones adyacentes que gestionan las sesiones o las autorizaciones de los usuarios, entre otras, por transparencia.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/032.pdf}
 \caption{Diagrama Entidad-Relaci\'on}
\label{fig:entidadrelacion}
\end{center}
\end{figure}


\subsubsection{Diagrama de Secuencia}\label{subsubsec:secuencia}

\noindent Se presentan en las figuras \ref{fig:secuencia1} y \ref{fig:secuencia2} dos Diagramas de Secuencia. Reflejan el subconjunto m\'as interesante de los mensajes intercambiados entre las entidades participantes en un procesado MapReduce. Estamos suponiendo que no se produce ning\'un error, que el usuario est\'a conectado a la interfaz con sus credenciales, que introduce correctamente todos los datos de definici\'on del procesado y que posee la autorizaci\'on necesaria para lanzar m\'aquinas virtuales en OpenStack. La figura \ref{fig:secuencia1} contiene la interacci\'on completa. La \ref{fig:secuencia2} expone con detalle la activaci\'on posterior al mensaje \texttt{\#24} de la figura \ref{fig:secuencia1}.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/033.pdf}
 \caption{Diagrama de Secuencia (I)}
\label{fig:secuencia1}
\end{center}
\end{figure}

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{imagenes/034.pdf}
 \caption{Diagrama de Secuencia (II)}
\label{fig:secuencia2}
\end{center}
\end{figure}

